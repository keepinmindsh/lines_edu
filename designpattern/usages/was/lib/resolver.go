package lib

import (
	"design_patterns/domain"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

type ResolverType string

const (
	StringView    ResolverType = "StringViewResolver"
	JsonView      ResolverType = "JsonViewResolver"
	MultiPartView ResolverType = "MultiPartView"
)

type get struct{}

func (g get) Resolve(param domain.ViewResolverConfig) {
	conn := param.Conn
	response, ok := param.Data.(string)
	if ok {
		fmt.Fprintf(conn, "HTTP/1.1 200 OK\r\n")
		fmt.Fprintf(conn, "Content-Length: %d\r\n", len(response))
		fmt.Fprintf(conn, "\r\n")
		fmt.Fprintf(conn, "%s\r\n", response)
	} else {
		response = "Type is not matched!"
		fmt.Fprintf(conn, "HTTP/1.1 200 OK\r\n")
		fmt.Fprintf(conn, "Content-Length: %d\r\n", len(response))
		fmt.Fprintf(conn, "\r\n")
		fmt.Fprintf(conn, "%s\r\n", response)
	}

}

func NewStringView() domain.ViewResolver {
	return &get{}
}

type post struct{}

func (p post) Resolve(param domain.ViewResolverConfig) {
	conn := param.Conn
	request, ok := param.Data.(string)

	if ok {
		content := strings.Split(request, "\r\n\r\n")[1]

		fmt.Fprintf(conn, "HTTP/1.1 200 OK\r\n")
		fmt.Fprintf(conn, "Content-Length: %d\r\n", len(content))
		fmt.Fprintf(conn, "\r\n")
		fmt.Fprintf(conn, "%s\r\n", content)
	} else {
		content := "Content is empty"

		fmt.Fprintf(conn, "HTTP/1.1 200 OK\r\n")
		fmt.Fprintf(conn, "Content-Length: %d\r\n", len(content))
		fmt.Fprintf(conn, "\r\n")
		fmt.Fprintf(conn, "%s\r\n", content)
	}
}

func NewJsonView() domain.ViewResolver {
	return &post{}
}

type fileIo struct{}

func (i fileIo) Resolve(param domain.ViewResolverConfig) {
	fileName, ok := param.Data.(string)
	if ok {
		// Open the file for reading
		file, err := os.Open("/Users/lines/sources/02_linesgits/lines_edu/designpattern/usages/was/lib/" + fileName)
		if err != nil {
			fmt.Println("Error opening file:", err)
			return
		}
		defer file.Close()

		// Determine the file size
		fileInfo, err := file.Stat()
		if err != nil {
			fmt.Println("Error getting file info:", err)
			return
		}
		fileSize := fileInfo.Size()

		// Construct the HTTP response header
		responseHeader := "HTTP/1.1 200 OK\r\nContent-Type: application/octet-stream\r\nContent-Length: " + strconv.Itoa(int(fileSize)) + "\r\n\r\n"

		// Send the HTTP response header
		_, err = param.Conn.Write([]byte(responseHeader))

		// Send the file contents
		_, err = io.Copy(param.Conn, file)
		if err != nil {
			fmt.Println("Error sending file contents:", err)
			return
		}
	} else {
		content := "Path is empty"

		fmt.Fprintf(param.Conn, "HTTP/1.1 200 OK\r\n")
		fmt.Fprintf(param.Conn, "Content-Length: %d\r\n", len(content))
		fmt.Fprintf(param.Conn, "\r\n")
		fmt.Fprintf(param.Conn, "%s\r\n", content)
	}
}

func NewMultiPartView() domain.ViewResolver {
	return &fileIo{}
}

type httpView struct {
}

func (h httpView) Resolve(param domain.ViewResolverConfig) {
	// Manually construct the HTTP response header
	header := "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: "
	htmlContent := `<!DOCTYPE html>
<html>
<head>
<title>HTML Response</title>
</head>
<body>
<p>This is an HTML response generated by Golang.</p>
</body>
</html>`
	htmlLength := len(htmlContent)
	header += strconv.Itoa(htmlLength) + "\r\n\r\n"

	// Write the response header
	_, err := param.Conn.Write([]byte(header))
	if err != nil {
		fmt.Println("Error writing response header:", err)
		return
	}

	// Write the HTML content
	_, err = param.Conn.Write([]byte(htmlContent))
	if err != nil {
		fmt.Println("Error writing HTML content:", err)
		return
	}
}

func NewHttpView() domain.ViewResolver {
	return &httpView{}
}
